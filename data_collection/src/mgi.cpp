#include <Eigen/Dense>
#include <cmath>
#include <iostream>
#include <ostream>

#include "mgi.h"

using Eigen::Matrix3d;
using Eigen::Vector3d;

Vector3d mgd(Vector3d &q) {
  Vector3d x;
  x(0) = std::cos(q(0)) * (L3 * std::sin(q(1) + q(2)) + L2 * std::sin(q(1))) -
         std::sin(q(0)) * (H2 + H3);
  x(1) = std::cos(q(0)) * (H2 + H3) +
         std::sin(q(0)) * (L3 * std::sin(q(1) + q(2)) + L2 * std::sin(q(1)));
  x(2) = H1 + L3 * std::cos(q(1) + q(2)) + L2 * std::cos(q(1));
  return x;
}

Vector3d f(Vector3d &q, Vector3d &Xd) { return Xd - mgd(q); }

Matrix3d J_pinv(Vector3d &q) {
  /*
   * This pseudo-inverse jacobian matrix was generated by Matlab.
   * Matlab code can be found in its own directory
   */
  Matrix3d J_pinv;

  const double theta1 = q(0);
  const double theta2 = q(1);
  const double theta3 = q(2);

  // Common sub-expressions
  const double s1 = std::sin(theta1);
  const double c1 = std::cos(theta1);
  const double s2 = std::sin(theta2);
  const double c2 = std::cos(theta2);
  const double s3 = std::sin(theta3);
  const double c3 = std::cos(theta3);

  const double s23 = std::sin(theta2 + theta3);
  const double c23 = std::cos(theta2 + theta3);

  // ---------- Row 1 ----------
  J_pinv(0, 0) = -s1 / (L3 * s23 + L2 * s2);
  J_pinv(0, 1) = c1 / (L3 * s23 + L2 * s2);
  J_pinv(0, 2) = 0.0;

  // ---------- Row 2 ----------
  const double denom2 = s2 * s3 * L2 * L2 - L3 * c2 * L2 * c3 * c3 +
                        L3 * s2 * s3 * L2 * c3 + L3 * c2 * L2;

  J_pinv(1, 0) = -(2 * L3 * c1 * c2 * c2 * c3 * c3 - L3 * c1 * c2 * c2 -
                   L3 * c1 * c3 * c3 - L2 * c1 * c3 + H2 * c2 * s1 * s3 +
                   H2 * c3 * s1 * s2 + H3 * c2 * s1 * s3 + H3 * c3 * s1 * s2 +
                   L2 * c1 * c2 * c2 * c3 - L2 * c1 * c2 * s2 * s3 -
                   2 * L3 * c1 * c2 * c3 * s2 * s3) /
                 denom2;

  J_pinv(1, 1) =
      (L2 * c3 * s1 + L3 * c2 * c2 * s1 + L3 * c3 * c3 * s1 -
       2 * L3 * c2 * c2 * c3 * c3 * s1 + H2 * c1 * c2 * s3 + H2 * c1 * c3 * s2 +
       H3 * c1 * c2 * s3 + H3 * c1 * c3 * s2 - L2 * c2 * c2 * c3 * s1 +
       L2 * c2 * s1 * s2 * s3 + 2 * L3 * c2 * c3 * s1 * s2 * s3) /
      denom2;

  J_pinv(1, 2) = c23 / (L2 * s3);

  // ---------- Row 3 ----------
  J_pinv(2, 0) = -(L2 * c1 * s2 - H3 * s1 - H2 * s1 + L3 * c1 * c2 * s3 +
                   L3 * c1 * c3 * s2) /
                 (L2 * L3 * s3);

  J_pinv(2, 1) = -(H2 * c1 + H3 * c1 + L2 * s1 * s2 + L3 * c2 * s1 * s3 +
                   L3 * c3 * s1 * s2) /
                 (L2 * L3 * s3);

  J_pinv(2, 2) = -(L3 * c23 + L2 * c2) / (L2 * L3 * s3);
  return J_pinv;
}

void gradient_descent(Vector3d &q, Vector3d &Xd) {
  q = q - J_pinv(q) * f(q, Xd);
}
