#include <Eigen/Dense>
#include <cmath>
#include <iostream>

using Eigen::Matrix3d;
using Eigen::Vector3d;

double l2 = 1.;
double l3 = 1.;
double h1 = 1.;
double h2 = 1.;
double h3 = 1.;

Vector3d mgd(Vector3d &q) {
  Vector3d x;
  x(0) = std::cos(q(0)) * (l3 * std::sin(q(1) + q(2)) + l2 * std::sin(q(1))) -
         std::sin(q(0)) * (h2 + h3);
  x(1) = std::cos(q(0)) * (h2 + h3) +
         std::sin(q(0)) * (l3 * std::sin(q(1) + q(2)) + l2 * std::sin(q(1)));
  x(2) = h1 + l3 * std::cos(q(1) + q(2)) + l2 * std::cos(q(1));
  return x;
}

Vector3d f(Vector3d &q, Vector3d &Xd) { return Xd - mgd(q); }

Matrix3d J_pinv(Vector3d &q) {
  /*
   * This pseudo-inverse jacobian matrix was generated by Matlab.
   * Matlab code can be found in its own directory
   */
  Matrix3d J_pinv;

  const double theta1 = q(0);
  const double theta2 = q(1);
  const double theta3 = q(2);

  // Common sub-expressions
  const double s1 = std::sin(theta1);
  const double c1 = std::cos(theta1);
  const double s2 = std::sin(theta2);
  const double c2 = std::cos(theta2);
  const double s3 = std::sin(theta3);
  const double c3 = std::cos(theta3);

  const double s23 = std::sin(theta2 + theta3);
  const double c23 = std::cos(theta2 + theta3);

  // ---------- Row 1 ----------
  J_pinv(0, 0) = -s1 / (l3 * s23 + l2 * s2);
  J_pinv(0, 1) = c1 / (l3 * s23 + l2 * s2);
  J_pinv(0, 2) = 0.0;

  // ---------- Row 2 ----------
  const double denom2 = s2 * s3 * l2 * l2 - l3 * c2 * l2 * c3 * c3 +
                        l3 * s2 * s3 * l2 * c3 + l3 * c2 * l2;

  J_pinv(1, 0) = -(2 * l3 * c1 * c2 * c2 * c3 * c3 - l3 * c1 * c2 * c2 -
                   l3 * c1 * c3 * c3 - l2 * c1 * c3 + h2 * c2 * s1 * s3 +
                   h2 * c3 * s1 * s2 + h3 * c2 * s1 * s3 + h3 * c3 * s1 * s2 +
                   l2 * c1 * c2 * c2 * c3 - l2 * c1 * c2 * s2 * s3 -
                   2 * l3 * c1 * c2 * c3 * s2 * s3) /
                 denom2;

  J_pinv(1, 1) =
      (l2 * c3 * s1 + l3 * c2 * c2 * s1 + l3 * c3 * c3 * s1 -
       2 * l3 * c2 * c2 * c3 * c3 * s1 + h2 * c1 * c2 * s3 + h2 * c1 * c3 * s2 +
       h3 * c1 * c2 * s3 + h3 * c1 * c3 * s2 - l2 * c2 * c2 * c3 * s1 +
       l2 * c2 * s1 * s2 * s3 + 2 * l3 * c2 * c3 * s1 * s2 * s3) /
      denom2;

  J_pinv(1, 2) = c23 / (l2 * s3);

  // ---------- Row 3 ----------
  J_pinv(2, 0) = -(l2 * c1 * s2 - h3 * s1 - h2 * s1 + l3 * c1 * c2 * s3 +
                   l3 * c1 * c3 * s2) /
                 (l2 * l3 * s3);

  J_pinv(2, 1) = -(h2 * c1 + h3 * c1 + l2 * s1 * s2 + l3 * c2 * s1 * s3 +
                   l3 * c3 * s1 * s2) /
                 (l2 * l3 * s3);

  J_pinv(2, 2) = -(l3 * c23 + l2 * c2) / (l2 * l3 * s3);
  return J_pinv;
}

void gradient_descent(Vector3d &q, Vector3d &Xd) {
  q = q - J_pinv(q) * f(q, Xd);
}

int main() {
  int max_iter = 10;

  Vector3d Xd(1., 1., 1.);
  Vector3d q(0., 0.5, 0.1);

  std::cout << "Basic q:" << q << std::endl;

  for (int i = 0; i < max_iter; i++) {
    gradient_descent(q, Xd);
    std::cout << "Middle q:" << q << std::endl;
  }
  std::cout << "Final q:" << q << std::endl;

  return 0;
}
